from collections import BitSet
from sys import CompilationTarget, external_call
from sys.ffi import c_char, c_int
from time.time import _CTimeSpec

from memory import Pointer, UnsafePointer
from utils import StaticTuple


# C types
alias c_void = UInt8
alias cc_t = UInt8
alias NCCS = Int8

alias tcflag_t = SIMD[(DType.uint32, DType.uint64)[Int(CompilationTarget.is_macos())], 1]
"""If `CompilationTarget.is_macos()` is true, use `UInt64`, otherwise use `UInt32`."""
alias c_speed_t = UInt64


@fieldwise_init
@register_passable("trivial")
struct ControlFlag:
    """Control mode flags."""

    var value: tcflag_t
    """Flag value."""
    alias CREAD = Self(2048) if CompilationTarget.is_macos() else Self(128)
    """Enable receiver."""
    alias CLOCAL = Self(32768) if CompilationTarget.is_macos() else Self(2048)
    """Ignore modem control lines."""
    alias PARENB = Self(4096) if CompilationTarget.is_macos() else Self(256)
    """Enable parity generation on output and parity checking on input."""
    alias CSIZE = Self(768) if CompilationTarget.is_macos() else Self(48)
    """Character size mask."""
    alias CS8 = Self(768)
    """8 bits per byte."""


@fieldwise_init
@register_passable("trivial")
struct LocalFlag:
    """Local mode flags."""

    var value: tcflag_t
    """Flag value."""
    alias ICANON = Self(256) if CompilationTarget.is_macos() else Self(2)
    """Canonical input processing."""
    alias ECHO = Self(8)
    """Enable echoing of input characters."""
    alias ECHOE = Self(2) if CompilationTarget.is_macos() else Self(16)
    """Echo erase character as error-correcting backspace."""
    alias ECHOK = Self(4) if CompilationTarget.is_macos() else Self(32)
    """Echo KILL character as a line kill."""
    alias ECHONL = Self(16) if CompilationTarget.is_macos() else Self(64)
    """Echo NL after CR on input."""
    alias ISIG = Self(128) if CompilationTarget.is_macos() else Self(1)
    """Enable signals generated by INTR, QUIT, SUSP, and DSUSP characters."""
    alias IEXTEN = Self(1024) if CompilationTarget.is_macos() else Self(32768)
    """Enable implementation-defined input processing.  This includes the use of the `START` and `STOP` characters for flow control."""
    alias NOFLSH = Self(2147483648) if CompilationTarget.is_macos() else Self(128)
    """Disable flushing of output and input queues when generating signals."""
    alias TOSTOP = Self(4194304) if CompilationTarget.is_macos() else Self(256)
    """Send SIGTTOU for background process on output."""


@fieldwise_init
@register_passable("trivial")
struct OutputFlag:
    """Output mode flags. These flags control how `stdout` behaves via output control."""

    var value: tcflag_t
    """Flag value."""
    alias OPOST = Self(1)
    """Enable implementation-defined output processing."""


@fieldwise_init
@register_passable("trivial")
struct InputFlag:
    """Input mode flags. These flags control how `stdin` behaves via input control."""

    var value: tcflag_t
    """Flag value."""
    alias INLCR = Self(64)
    """Map NL to CR on input."""
    alias IGNCR = Self(128)
    """Ignore CR on input."""
    alias ICRNL = Self(256)
    """Translate carriage return to newline on input (unless IGNCR is set)."""
    alias IGNBRK = Self(1)
    """Ignore BREAK condition on input.
    If IGNBRK is set, a BREAK is ignored.  If it is not set
    but BRKINT is set, then a BREAK causes the input and
    output queues to be flushed, and if the terminal is the
    controlling terminal of a foreground process group, it
    will cause a SIGINT to be sent to this foreground process
    group.  When neither IGNBRK nor BRKINT are set, a BREAK
    reads as a null byte ('\\0'), except when PARMRK is set, in
    which case it reads as the sequence \\377 \\0 \\0."""
    alias BRKINT = Self(2)
    alias IGNPAR = Self(4)
    """Ignore framing errors and parity errors.
    If this bit is set, input bytes with parity or framing
    errors are marked when passed to the program.  This bit is
    meaningful only when INPCK is set and IGNPAR is not set.
    The way erroneous bytes are marked is with two preceding
    bytes, \\377 and \\0.  Thus, the program actually reads
    three bytes for one erroneous byte received from the
    terminal.  If a valid byte has the value \\377, and ISTRIP
    (see below) is not set, the program might confuse it with
    the prefix that marks a parity error.  Therefore, a valid
    byte \\377 is passed to the program as two bytes, \\377
    \\377, in this case."""

    # If neither IGNPAR nor PARMRK is set, read a character with
    # a parity error or framing error as \0.

    alias PARMRK = Self(8)
    """Mark parity and framing errors."""
    alias INPCK = Self(16)
    """Enable input parity checking."""
    alias ISTRIP = Self(32)
    """Strip off eighth bit."""

    alias IXON = Self(512) if CompilationTarget.is_macos() else Self(1024)
    """Enable XON/XOFF flow control on output."""
    alias IXANY = Self(2048)
    """(XSI) Typing any character will restart stopped output. (The default is to allow just the START character to restart output.)"""
    alias IXOFF = Self(1024) if CompilationTarget.is_macos() else Self(4096)
    """Enable XON/XOFF flow control on input."""

    # alias IMAXBEL
    #         (not in POSIX) Ring bell when input queue is full.  Linux
    #         does not implement this bit, and acts as if it is always
    #         set.

    # alias IUTF8 (since Linux 2.6.4)
    #         (not in POSIX) Input is UTF8; this allows character-erase
    #         to be correctly performed in cooked mode.


@fieldwise_init
@register_passable("trivial")
struct SpecialCharacter:
    """Special Character indexes for control characters."""

    var value: cc_t
    """Special control characters."""

    alias VEOF = Self(0) if CompilationTarget.is_macos() else Self(4)
    """Signal End-Of-Input `Ctrl-D`"""
    alias VEOL = Self(1) if CompilationTarget.is_macos() else Self(11)
    """Signal End-Of-Line `Disabled`"""
    alias VERASE = Self(3) if CompilationTarget.is_macos() else Self(2)
    """Delete previous character `Backspace`"""
    alias VINTR = Self(8) if CompilationTarget.is_macos() else Self(0)
    """Generate SIGINT `Ctrl-C`"""
    alias VKILL = Self(5) if CompilationTarget.is_macos() else Self(3)
    """Erase current line `Ctrl-U`"""
    alias VMIN = Self(16) if CompilationTarget.is_macos() else Self(6)
    """The MIN value `1`"""
    alias VQUIT = Self(9) if CompilationTarget.is_macos() else Self(1)
    """Generate SIGQUIT `Ctrl-\\`"""
    alias VSTART = Self(12) if CompilationTarget.is_macos() else Self(8)
    """Resume output `Ctrl-Q`"""
    alias VSTOP = Self(13) if CompilationTarget.is_macos() else Self(9)
    """Suspend output `Ctrl-S`"""
    alias VSUSP = Self(10)
    """Suspend program `Ctrl-Z`"""
    alias VTIME = Self(17) if CompilationTarget.is_macos() else Self(5)
    """The TIME value `0`"""


@fieldwise_init
@register_passable("trivial")
struct Termios(Copyable, ExplicitlyCopyable, Movable, Stringable, Writable):
    """Termios libc."""

    alias _CONTROL_CHARACTER_WIDTH = 20 if CompilationTarget.is_macos() else 32

    var c_iflag: tcflag_t
    """Input mode flags."""
    var c_oflag: tcflag_t
    """Output mode flags."""
    var c_cflag: tcflag_t
    """Control mode flags."""
    var c_lflag: tcflag_t
    """Local mode flags."""
    var c_cc: StaticTuple[cc_t, Self._CONTROL_CHARACTER_WIDTH]
    """Special control characters."""
    var c_ispeed: c_speed_t
    """Input baudrate."""
    var c_ospeed: c_speed_t
    """Output baudrate."""

    fn __init__(out self):
        """Initializes the Termios struct with default values."""
        self.c_cc = StaticTuple[cc_t, Self._CONTROL_CHARACTER_WIDTH]()

        @parameter
        for n in range(Self._CONTROL_CHARACTER_WIDTH):
            self.c_cc[n] = 0

        self.c_cflag = 0
        self.c_lflag = 0
        self.c_iflag = 0
        self.c_oflag = 0
        self.c_ispeed = 0
        self.c_ospeed = 0

    fn write_to[W: Writer, //](self, mut writer: W):
        """Writes the contents of the buffer to the writer.

        Parameters:
            W: The type of writer to write the contents to.

        Args:
            writer: The writer to write the contents to.
        """
        writer.write(
            "Termios(",
            "c_iflag=",
            self.c_iflag,
            ", ",
            "c_oflag=",
            self.c_oflag,
            ", ",
            "c_cflag=",
            self.c_cflag,
            ", ",
            "c_lflag=",
            self.c_lflag,
            ", ",
            "c_ispeed=",
            self.c_ispeed,
            ", ",
            "c_ospeed=",
            self.c_ospeed,
            ", ",
            "c_cc=(",
        )

        @parameter
        for i in range(20):
            writer.write(self.c_cc[i], ", ")
        writer.write(")")

    fn __str__(self) -> String:
        """Converts the Termios struct to a string representation.

        Returns:
            A string representation of the Termios struct.
        """
        return String.write(self)


fn tcgetattr(fd: c_int, termios_p: Pointer[mut=True, Termios]) -> c_int:
    """Libc POSIX `tcgetattr` function.

    Get the parameters associated with the terminal referred to by the file descriptor `fd`.

    Args:
        fd: File descriptor.
        termios_p: Termios struct.

    Returns:
        The result of the operation, typically 0 on success or -1 in case of failure.

    #### C Function:
    ```c
    int tcgetattr(int fd, struct Termios *termios_p);
    ```

    #### Notes:
    Reference: https://man7.org/linux/man-pages/man3/tcgetattr.3.html.
    """
    return external_call["tcgetattr", c_int](fd, termios_p)


fn tcsetattr(fd: c_int, optional_actions: c_int, termios_p: Pointer[mut=False, Termios]) -> c_int:
    """Libc POSIX `tcsetattr` function.

    Set the parameters associated with the terminal referred to by the file descriptor `fd`.

    Args:
        fd: File descriptor.
        optional_actions: Optional actions.
        termios_p: Termios struct.

    Returns:
        The result of the operation, typically 0 on success or -1 in case of failure.

    #### C Function:
    ```c
    int tcsetattr(int fd, int optional_actions, const struct Termios *termios_p);
    ```

    #### Notes:
    Reference: https://man7.org/linux/man-pages/man3/tcsetattr.3.html.
    """
    return external_call["tcsetattr", c_int](fd, optional_actions, termios_p)


fn tcsendbreak(fd: c_int, duration: c_int) -> c_int:
    """Libc POSIX `tcsendbreak` function.

    Send a break on the terminal referred to by the file descriptor `fd`.

    Args:
        fd: File descriptor.
        duration: Duration.

    Returns:
        The result of the operation, typically 0 on success or -1 in case of failure.

    #### C Function:
    ```c
    int tcsendbreak(int fd, int duration);
    ```

    #### Notes:
    Reference: https://man7.org/linux/man-pages/man3/tcsendbreak.3.html.
    """
    return external_call["tcsendbreak", c_int, c_int, c_int](fd, duration)


fn tcdrain(fd: c_int) -> c_int:
    """Libc POSIX `tcdrain` function.

    Drain the output buffer of the terminal referred to by the file descriptor `fd`.

    Args:
        fd: File descriptor.

    Returns:
        The result of the operation, typically 0 on success or -1 in case of failure.

    #### C Function:
    ```c
    int tcdrain(int fd);
    ```

    #### Notes:
    Reference: https://man7.org/linux/man-pages/man3/tcdrain.3.html.
    """
    return external_call["tcdrain", c_int, c_int](fd)


fn tcflush(fd: c_int, queue_selector: c_int) -> c_int:
    """Libc POSIX `tcflush` function.

    Flush the data transmitted or received on the terminal referred to by the file descriptor `fd`.

    Args:
        fd: File descriptor.
        queue_selector: Queue selector.

    Returns:
        The result of the operation, typically 0 on success or -1 in case of failure.

    #### C Function:
    ```c
    int tcflush(int fd, int queue_selector);
    ```

    #### Notes:
    Reference: https://man7.org/linux/man-pages/man3/tcflush.3.html.
    """
    return external_call["tcflush", c_int, c_int, c_int](fd, queue_selector)


fn tcflow(fd: c_int, action: c_int) -> c_int:
    """Libc POSIX `tcflow` function.

    Suspend or resume transmission on the terminal referred to by the file descriptor `fd`.

    Args:
        fd: File descriptor.
        action: Action.

    Returns:
        The result of the operation, typically 0 on success or -1 on failure.

    #### C Function:
    ```c
    int tcflow(int fd, int action);
    ```

    #### Notes:
    Reference: https://man7.org/linux/man-pages/man3/tcflow.3.html.
    """
    return external_call["tcflow", c_int, c_int, c_int](fd, action)


fn cfmakeraw(termios_p: Pointer[Termios]) -> c_void:
    """Libc POSIX `cfmakeraw` function.

    Set the terminal attributes to raw mode.

    Args:
        termios_p: Reference to a Termios struct.

    Returns:
        A c_void value.

    #### C Function:
    ```c
    void cfmakeraw(struct Termios *termios_p);
    ```

    #### Notes:
    Reference: https://man7.org/linux/man-pages/man3/cfmakeraw.3.html.
    """
    return external_call["cfmakeraw", c_void](termios_p)


# @fieldwise_init
# @register_passable("trivial")
# struct winsize():
#     var ws_row: UInt8      # Number of rows, in characters */
#     var ws_col: UInt8      # Number of columns, in characters */
#     var ws_xpixel: UInt8   # Width, in pixels */
#     var ws_ypixel: UInt8   # Height, in pixels */

#     fn __init__(out self):
#         self.ws_row = 0
#         self.ws_col = 0
#         self.ws_xpixel = 0
#         self.ws_ypixel = 0


# fn tcgetwinsize(fd: c_int, winsize_p: UnsafePointer[winsize]) -> c_int:
#     """Libc POSIX `tcgetwinsize` function
#     Reference: https://man.netbsd.org/tcgetwinsize.3
#     Fn signature: int tcgetwinsize(int fd, struct winsize *gws).

#     Args:
#         fd: File descriptor.
#         winsize_p: Pointer to a winsize struct.
#     """
#     return external_call["tcgetwinsize", c_int, c_int, UnsafePointer[winsize]](fd, winsize_p)


# fn tcsetwinsize(fd: c_int, winsize_p: UnsafePointer[winsize]) -> c_int:
#     """Libc POSIX `tcgetwinsize` function
#     Reference: https://man.netbsd.org/tcsetwinsize.3
#     Fn signature: int tcsetwinsize(int fd, const struct winsize *sws).

#     Args:
#         fd: File descriptor.
#         winsize_p: Pointer to a winsize struct.
#     """
#     return external_call["tcsetwinsize", c_int, c_int, UnsafePointer[winsize]](fd, winsize_p)


fn get_errno() -> c_int:
    """Get a copy of the current value of the `errno` global variable for
    the current thread.

    Returns:
        A copy of the current value of `errno` for the current thread.
    """

    @parameter
    if CompilationTarget.is_windows():
        var errno = InlineArray[c_int, 1]()
        _ = external_call["_get_errno", c_void](errno.unsafe_ptr())
        return errno[0]
    else:
        alias loc = "__error" if CompilationTarget.is_macos() else "__errno_location"
        return external_call[loc, UnsafePointer[c_int]]()[]


# --- ( error.h Constants )-----------------------------------------------------
# TODO: These are probably platform specific, we should check the values on each linux and macos.
alias EPERM = 1
alias ENOENT = 2
alias ESRCH = 3
alias EINTR = 4
alias EIO = 5
alias ENXIO = 6
alias E2BIG = 7
alias ENOEXEC = 8
alias EBADF = 9
alias ECHILD = 10
alias EAGAIN = 11
alias ENOMEM = 12
alias EACCES = 13
alias EFAULT = 14
alias ENOTBLK = 15
alias EBUSY = 16
alias EEXIST = 17
alias EXDEV = 18
alias ENODEV = 19
alias ENOTDIR = 20
alias EISDIR = 21
alias EINVAL = 22
alias ENFILE = 23
alias EMFILE = 24
alias ENOTTY = 25
alias ETXTBSY = 26
alias EFBIG = 27
alias ENOSPC = 28
alias ESPIPE = 29
alias EROFS = 30
alias EMLINK = 31
alias EPIPE = 32
alias EDOM = 33
alias ERANGE = 34
alias EWOULDBLOCK = EAGAIN
alias EINPROGRESS = 36 if CompilationTarget.is_macos() else 115
alias EALREADY = 37 if CompilationTarget.is_macos() else 114
alias ENOTSOCK = 38 if CompilationTarget.is_macos() else 88
alias EDESTADDRREQ = 39 if CompilationTarget.is_macos() else 89
alias EMSGSIZE = 40 if CompilationTarget.is_macos() else 90
alias ENOPROTOOPT = 42 if CompilationTarget.is_macos() else 92
alias EAFNOSUPPORT = 47 if CompilationTarget.is_macos() else 97
alias EADDRINUSE = 48 if CompilationTarget.is_macos() else 98
alias EADDRNOTAVAIL = 49 if CompilationTarget.is_macos() else 99
alias ENETDOWN = 50 if CompilationTarget.is_macos() else 100
alias ENETUNREACH = 51 if CompilationTarget.is_macos() else 101
alias ECONNABORTED = 53 if CompilationTarget.is_macos() else 103
alias ECONNRESET = 54 if CompilationTarget.is_macos() else 104
alias ENOBUFS = 55 if CompilationTarget.is_macos() else 105
alias EISCONN = 56 if CompilationTarget.is_macos() else 106
alias ENOTCONN = 57 if CompilationTarget.is_macos() else 107
alias ETIMEDOUT = 60 if CompilationTarget.is_macos() else 110
alias ECONNREFUSED = 61 if CompilationTarget.is_macos() else 111
alias ELOOP = 62 if CompilationTarget.is_macos() else 40
alias ENAMETOOLONG = 63 if CompilationTarget.is_macos() else 36
alias EHOSTUNREACH = 65 if CompilationTarget.is_macos() else 113
alias EDQUOT = 69 if CompilationTarget.is_macos() else 122
alias ENOMSG = 91 if CompilationTarget.is_macos() else 42
alias EPROTO = 100 if CompilationTarget.is_macos() else 71
alias EOPNOTSUPP = 102 if CompilationTarget.is_macos() else 95


fn isatty(fd: c_int) -> Bool:
    """Libc POSIX `isatty` function.

    Check if the file descriptor `fd` refers to a terminal.

    Args:
        fd: File descriptor.

    Returns:
        True if `fd` refers to a terminal, False otherwise.

    #### C Function:
    ```c
    int isatty(int fd);
    ```

    #### Notes:
    Reference: https://man7.org/linux/man-pages/man3/isatty.3p.html.
    """
    return external_call["isatty", Int, c_int](fd)


fn ttyname(fd: c_int) -> UnsafePointer[c_char]:
    """Libc POSIX `ttyname` function.

    Get the name of the terminal associated with the file descriptor `fd`.

    Args:
        fd: File descriptor.

    Returns:
        A pointer to a string containing the name of the terminal.

    #### C Function:
    ```c
    char *ttyname(int fd);
    ```

    #### Notes:
    Reference: https://man7.org/linux/man-pages/man3/ttyname.3p.html.
    """
    return external_call["ttyname", UnsafePointer[c_char], c_int](fd)


fn read(fd: c_int, buf: UnsafePointer[c_void], size: UInt) -> c_int:
    """Libc POSIX `read` function.

    Read `size` bytes from file descriptor `fd` into the buffer `buf`.

    Args:
        fd: A File Descriptor.
        buf: A pointer to a buffer to store the read data.
        size: The number of bytes to read.

    Returns:
        The number of bytes read or -1 in case of failure.

    #### C Function:Add commentMore actions
    ```c
    ssize_t read(int fildes, void *buf, size_t nbyte);
    ```

    #### Notes:
    Reference: https://man7.org/linux/man-pages/man3/read.3p.html.
    """
    return external_call["read", Int, c_int, UnsafePointer[c_void], UInt](fd, buf, size)


alias FileDescriptorBitSet = BitSet[1024]


@fieldwise_init
@register_passable("trivial")
struct _TimeValue(Copyable, ExplicitlyCopyable, Movable):
    var seconds: Int64
    var microseconds: Int64


fn _select(
    nfds: c_int,
    readfds: Pointer[mut=True, BitSet[1024]],
    writefds: Pointer[mut=True, BitSet[1]],
    exceptfds: Pointer[mut=True, BitSet[1]],
    timeout: Pointer[mut=True, _TimeValue],
) -> c_int:
    """Libc POSIX `select` function.

    Args:
        nfds: The highest-numbered file descriptor in any of the three sets, plus 1.
        readfds: A pointer to the set of file descriptors to read from.
        writefds: A pointer to the set of file descriptors to write to.
        exceptfds: A pointer to the set of file descriptors to check for exceptions.
        timeout: A pointer to a TimeValue struct to set a timeout.

    Returns:
        The number of file descriptors in the sets or -1 in case of failure.

    #### C Function:
    ```c
    int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
    ```

    #### Notes:
    Reference: https://man7.org/linux/man-pages/man2/select.2.html
    """
    return external_call[
        "select",
        c_int,  # FnName, RetType
    ](nfds, readfds, writefds, exceptfds, timeout)


fn select(
    highest_fd: c_int,
    mut read_fds: BitSet[1024],
    mut write_fds: BitSet[1],
    mut except_fds: BitSet[1],
    mut timeout: _TimeValue,
) raises -> None:
    """Libc POSIX `select` function.

    Args:
        highest_fd: The highest-numbered file descriptor in any of the three sets, plus 1.
        read_fds: A pointer to the set of file descriptors to read from.
        write_fds: A pointer to the set of file descriptors to write to.
        except_fds: A pointer to the set of file descriptors to check for exceptions.
        timeout: A pointer to a TimeValue struct to set a timeout.

    #### C Function Signature:
    ```c
    int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
    ```

    #### Reference
    https://man7.org/linux/man-pages/man2/select.2.html.
    """
    var result = _select(
        highest_fd,
        Pointer(to=read_fds),
        Pointer(to=write_fds),
        Pointer(to=except_fds),
        Pointer(to=timeout),
    )

    if result == -1:
        var errno = c.get_errno()
        if errno == c.EBADF:
            raise Error("[EBADF] An invalid file descriptor was given in one of the sets.")
        elif errno == c.EINTR:
            raise Error("[EINTR] A signal was caught.")
        elif errno == c.EINVAL:
            raise Error("[EINVAL] nfds is negative or exceeds the RLIMIT_NOFILE resource limit.")
        elif errno == c.ENOMEM:
            raise Error("[ENOMEM] Unable to allocate memory for internal tables.")
        else:
            raise Error("[UNKNOWN] Unknown error occurred.")
    elif result == 0:
        raise Error("Select has timed out while waiting for file descriptors to become ready.")
