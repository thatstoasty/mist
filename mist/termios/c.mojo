from collections import BitSet
from sys import CompilationTarget
from time.time import _CTimeSpec

from sys.ffi import c_char, c_int, c_size_t, external_call, get_errno
from utils import StaticTuple


# C types
comptime c_void = NoneType
"""C void type."""
comptime cc_t = UInt8
"""C control character type."""
comptime NCCS = Int8
"""Number of control characters."""
comptime time_t = Int64
"""C time type."""
comptime suseconds_t = Int64
"""C microsecond time type."""
comptime MutExternalPointer = UnsafePointer[origin=MutExternalOrigin]
"""A mutable external pointer type."""
comptime ImmutExternalPointer = UnsafePointer[origin=ImmutExternalOrigin]
"""An immutable external pointer type."""

comptime tcflag_t = SIMD[(DType.uint32, DType.uint64)[Int(CompilationTarget.is_macos())], 1]
"""If `CompilationTarget.is_macos()` is true, use `UInt64`, otherwise use `UInt32`."""
comptime c_speed_t = UInt64
"""C speed type."""


@fieldwise_init
@register_passable("trivial")
struct ControlFlag:
    """Control mode flags."""

    var value: tcflag_t
    """Flag value."""
    comptime CREAD = Self(2048) if CompilationTarget.is_macos() else Self(128)
    """Enable receiver."""
    comptime CLOCAL = Self(32768) if CompilationTarget.is_macos() else Self(2048)
    """Ignore modem control lines."""
    comptime PARENB = Self(4096) if CompilationTarget.is_macos() else Self(256)
    """Enable parity generation on output and parity checking on input."""
    comptime CSIZE = Self(768) if CompilationTarget.is_macos() else Self(48)
    """Character size mask."""
    comptime CS8 = Self(768)
    """8 bits per byte."""


@fieldwise_init
@register_passable("trivial")
struct LocalFlag:
    """Local mode flags."""

    var value: tcflag_t
    """Flag value."""
    comptime ICANON = Self(256) if CompilationTarget.is_macos() else Self(2)
    """Canonical input processing."""
    comptime ECHO = Self(8)
    """Enable echoing of input characters."""
    comptime ECHOE = Self(2) if CompilationTarget.is_macos() else Self(16)
    """Echo erase character as error-correcting backspace."""
    comptime ECHOK = Self(4) if CompilationTarget.is_macos() else Self(32)
    """Echo KILL character as a line kill."""
    comptime ECHONL = Self(16) if CompilationTarget.is_macos() else Self(64)
    """Echo NL after CR on input."""
    comptime ISIG = Self(128) if CompilationTarget.is_macos() else Self(1)
    """Enable signals generated by INTR, QUIT, SUSP, and DSUSP characters."""
    comptime IEXTEN = Self(1024) if CompilationTarget.is_macos() else Self(32768)
    """Enable implementation-defined input processing.  This includes the use of the `START` and `STOP` characters for flow control."""
    comptime NOFLSH = Self(2147483648) if CompilationTarget.is_macos() else Self(128)
    """Disable flushing of output and input queues when generating signals."""
    comptime TOSTOP = Self(4194304) if CompilationTarget.is_macos() else Self(256)
    """Send SIGTTOU for background process on output."""


@fieldwise_init
@register_passable("trivial")
struct OutputFlag:
    """Output mode flags. These flags control how `stdout` behaves via output control."""

    var value: tcflag_t
    """Flag value."""
    comptime OPOST = Self(1)
    """Enable implementation-defined output processing."""


@fieldwise_init
@register_passable("trivial")
struct InputFlag:
    """Input mode flags. These flags control how `stdin` behaves via input control."""

    var value: tcflag_t
    """Flag value."""
    comptime INLCR = Self(64)
    """Map NL to CR on input."""
    comptime IGNCR = Self(128)
    """Ignore CR on input."""
    comptime ICRNL = Self(256)
    """Translate carriage return to newline on input (unless IGNCR is set)."""
    comptime IGNBRK = Self(1)
    """Ignore BREAK condition on input.
    If IGNBRK is set, a BREAK is ignored.  If it is not set
    but BRKINT is set, then a BREAK causes the input and
    output queues to be flushed, and if the terminal is the
    controlling terminal of a foreground process group, it
    will cause a SIGINT to be sent to this foreground process
    group.  When neither IGNBRK nor BRKINT are set, a BREAK
    reads as a null byte ('\\0'), except when PARMRK is set, in
    which case it reads as the sequence \\377 \\0 \\0."""
    comptime BRKINT = Self(2)
    """Signal interrupt on BREAK."""
    comptime IGNPAR = Self(4)
    """Ignore framing errors and parity errors.
    If this bit is set, input bytes with parity or framing
    errors are marked when passed to the program.  This bit is
    meaningful only when INPCK is set and IGNPAR is not set.
    The way erroneous bytes are marked is with two preceding
    bytes, \\377 and \\0.  Thus, the program actually reads
    three bytes for one erroneous byte received from the
    terminal.  If a valid byte has the value \\377, and ISTRIP
    (see below) is not set, the program might confuse it with
    the prefix that marks a parity error.  Therefore, a valid
    byte \\377 is passed to the program as two bytes, \\377
    \\377, in this case."""

    # If neither IGNPAR nor PARMRK is set, read a character with
    # a parity error or framing error as \0.

    comptime PARMRK = Self(8)
    """Mark parity and framing errors."""
    comptime INPCK = Self(16)
    """Enable input parity checking."""
    comptime ISTRIP = Self(32)
    """Strip off eighth bit."""

    comptime IXON = Self(512) if CompilationTarget.is_macos() else Self(1024)
    """Enable XON/XOFF flow control on output."""
    comptime IXANY = Self(2048)
    """(XSI) Typing any character will restart stopped output. (The default is to allow just the START character to restart output)."""
    comptime IXOFF = Self(1024) if CompilationTarget.is_macos() else Self(4096)
    """Enable XON/XOFF flow control on input."""

    # comptime IMAXBEL
    #         (not in POSIX) Ring bell when input queue is full.  Linux
    #         does not implement this bit, and acts as if it is always
    #         set.

    # comptime IUTF8 (since Linux 2.6.4)
    #         (not in POSIX) Input is UTF8; this allows character-erase
    #         to be correctly performed in cooked mode.


@fieldwise_init
@register_passable("trivial")
struct SpecialCharacter:
    """Special Character indexes for control characters."""

    var value: cc_t
    """Special control characters."""

    comptime VEOF = Self(0) if CompilationTarget.is_macos() else Self(4)
    """Signal End-Of-Input `Ctrl-D`."""
    comptime VEOL = Self(1) if CompilationTarget.is_macos() else Self(11)
    """Signal End-Of-Line `Disabled`."""
    comptime VERASE = Self(3) if CompilationTarget.is_macos() else Self(2)
    """Delete previous character `Backspace`."""
    comptime VINTR = Self(8) if CompilationTarget.is_macos() else Self(0)
    """Generate SIGINT `Ctrl-C`."""
    comptime VKILL = Self(5) if CompilationTarget.is_macos() else Self(3)
    """Erase current line `Ctrl-U`."""
    comptime VMIN = Self(16) if CompilationTarget.is_macos() else Self(6)
    """The MIN value `1`."""
    comptime VQUIT = Self(9) if CompilationTarget.is_macos() else Self(1)
    """Generate SIGQUIT `Ctrl-\\`."""
    comptime VSTART = Self(12) if CompilationTarget.is_macos() else Self(8)
    """Resume output `Ctrl-Q`."""
    comptime VSTOP = Self(13) if CompilationTarget.is_macos() else Self(9)
    """Suspend output `Ctrl-S`."""
    comptime VSUSP = Self(10)
    """Suspend program `Ctrl-Z`."""
    comptime VTIME = Self(17) if CompilationTarget.is_macos() else Self(5)
    """The TIME value `0`."""


@fieldwise_init
@register_passable("trivial")
struct Termios(Copyable, Stringable, Writable):
    """Termios libc."""

    comptime _CONTROL_CHARACTER_WIDTH = 20 if CompilationTarget.is_macos() else 32

    var c_iflag: tcflag_t
    """Input mode flags."""
    var c_oflag: tcflag_t
    """Output mode flags."""
    var c_cflag: tcflag_t
    """Control mode flags."""
    var c_lflag: tcflag_t
    """Local mode flags."""
    var c_cc: StaticTuple[cc_t, Self._CONTROL_CHARACTER_WIDTH]
    """Special control characters."""
    var c_ispeed: c_speed_t
    """Input baudrate."""
    var c_ospeed: c_speed_t
    """Output baudrate."""

    fn __init__(out self):
        """Initializes the Termios struct with default values."""
        self.c_cc = StaticTuple[cc_t, Self._CONTROL_CHARACTER_WIDTH]()

        @parameter
        for n in range(Self._CONTROL_CHARACTER_WIDTH):
            self.c_cc[n] = 0

        self.c_cflag = 0
        self.c_lflag = 0
        self.c_iflag = 0
        self.c_oflag = 0
        self.c_ispeed = 0
        self.c_ospeed = 0

    fn write_to(self, mut writer: Some[Writer]):
        """Writes the contents of the buffer to the writer.

        Args:
            writer: The writer to write the contents to.
        """
        writer.write(
            "Termios(",
            "c_iflag=",
            self.c_iflag,
            ", ",
            "c_oflag=",
            self.c_oflag,
            ", ",
            "c_cflag=",
            self.c_cflag,
            ", ",
            "c_lflag=",
            self.c_lflag,
            ", ",
            "c_ispeed=",
            self.c_ispeed,
            ", ",
            "c_ospeed=",
            self.c_ospeed,
            ", ",
            "c_cc=(",
        )

        @parameter
        for i in range(20):
            writer.write(self.c_cc[i], ", ")
        writer.write(")")

    fn __str__(self) -> String:
        """Converts the Termios struct to a string representation.

        Returns:
            A string representation of the Termios struct.
        """
        return String.write(self)


fn tcgetattr[origin: MutOrigin](fd: c_int, termios_p: Pointer[mut=True, Termios, origin]) -> c_int:
    """Libc POSIX `tcgetattr` function.

    Get the parameters associated with the terminal referred to by the file descriptor `fd`.

    Parameters:
        origin: The origin of the Termios pointer.

    Args:
        fd: File descriptor.
        termios_p: Termios struct.

    Returns:
        The result of the operation, typically 0 on success or -1 in case of failure.

    #### C Function:
    ```c
    int tcgetattr(int fd, struct Termios *termios_p);
    ```

    #### Notes:
    Reference: https://man7.org/linux/man-pages/man3/tcgetattr.3.html.
    """
    return external_call["tcgetattr", c_int, c_int, Pointer[mut=True, Termios, origin]](fd, termios_p)


fn tcsetattr[
    origin: ImmutOrigin
](fd: c_int, optional_actions: c_int, termios_p: Pointer[mut=False, Termios, origin]) -> c_int:
    """Libc POSIX `tcsetattr` function.

    Set the parameters associated with the terminal referred to by the file descriptor `fd`.

    Parameters:
        origin: The origin of the Termios pointer.

    Args:
        fd: File descriptor.
        optional_actions: Optional actions.
        termios_p: Termios struct.

    Returns:
        The result of the operation, typically 0 on success or -1 in case of failure.

    #### C Function:
    ```c
    int tcsetattr(int fd, int optional_actions, const struct Termios *termios_p);
    ```

    #### Notes:
    Reference: https://man7.org/linux/man-pages/man3/tcsetattr.3.html.
    """
    return external_call["tcsetattr", c_int, c_int, c_int, Pointer[mut=False, Termios, origin]](
        fd, optional_actions, termios_p
    )


fn tcsendbreak(fd: c_int, duration: c_int) -> c_int:
    """Libc POSIX `tcsendbreak` function.

    Send a break on the terminal referred to by the file descriptor `fd`.

    Args:
        fd: File descriptor.
        duration: Duration.

    Returns:
        The result of the operation, typically 0 on success or -1 in case of failure.

    #### C Function:
    ```c
    int tcsendbreak(int fd, int duration);
    ```

    #### Notes:
    Reference: https://man7.org/linux/man-pages/man3/tcsendbreak.3.html.
    """
    return external_call["tcsendbreak", c_int, c_int, c_int](fd, duration)


fn tcdrain(fd: c_int) -> c_int:
    """Libc POSIX `tcdrain` function.

    Drain the output buffer of the terminal referred to by the file descriptor `fd`.

    Args:
        fd: File descriptor.

    Returns:
        The result of the operation, typically 0 on success or -1 in case of failure.

    #### C Function:
    ```c
    int tcdrain(int fd);
    ```

    #### Notes:
    Reference: https://man7.org/linux/man-pages/man3/tcdrain.3.html.
    """
    return external_call["tcdrain", c_int, c_int](fd)


fn tcflush(fd: c_int, queue_selector: c_int) -> c_int:
    """Libc POSIX `tcflush` function.

    Flush the data transmitted or received on the terminal referred to by the file descriptor `fd`.

    Args:
        fd: File descriptor.
        queue_selector: Queue selector.

    Returns:
        The result of the operation, typically 0 on success or -1 in case of failure.

    #### C Function:
    ```c
    int tcflush(int fd, int queue_selector);
    ```

    #### Notes:
    Reference: https://man7.org/linux/man-pages/man3/tcflush.3.html.
    """
    return external_call["tcflush", c_int, c_int, c_int](fd, queue_selector)


fn tcflow(fd: c_int, action: c_int) -> c_int:
    """Libc POSIX `tcflow` function.

    Suspend or resume transmission on the terminal referred to by the file descriptor `fd`.

    Args:
        fd: File descriptor.
        action: Action.

    Returns:
        The result of the operation, typically 0 on success or -1 on failure.

    #### C Function:
    ```c
    int tcflow(int fd, int action);
    ```

    #### Notes:
    Reference: https://man7.org/linux/man-pages/man3/tcflow.3.html.
    """
    return external_call["tcflow", c_int, c_int, c_int](fd, action)


fn cfmakeraw[origin: MutOrigin](termios_p: Pointer[mut=True, Termios, origin]):
    """Libc POSIX `cfmakeraw` function.

    Set the terminal attributes to raw mode.

    Parameters:
        origin: The origin of the Termios pointer.

    Args:
        termios_p: Reference to a Termios struct.

    #### C Function:
    ```c
    void cfmakeraw(struct Termios *termios_p);
    ```

    #### Notes:
    Reference: https://man7.org/linux/man-pages/man3/cfmakeraw.3.html.
    """
    external_call["cfmakeraw", c_void, Pointer[mut=True, Termios, origin]](termios_p)


# @fieldwise_init
# @register_passable("trivial")
# struct winsize():
#     var ws_row: UInt8      # Number of rows, in characters */
#     var ws_col: UInt8      # Number of columns, in characters */
#     var ws_xpixel: UInt8   # Width, in pixels */
#     var ws_ypixel: UInt8   # Height, in pixels */

#     fn __init__(out self):
#         self.ws_row = 0
#         self.ws_col = 0
#         self.ws_xpixel = 0
#         self.ws_ypixel = 0


# fn tcgetwinsize(fd: c_int, winsize_p: UnsafePointer[winsize]) -> c_int:
#     """Libc POSIX `tcgetwinsize` function
#     Reference: https://man.netbsd.org/tcgetwinsize.3
#     Fn signature: int tcgetwinsize(int fd, struct winsize *gws).

#     Args:
#         fd: File descriptor.
#         winsize_p: Pointer to a winsize struct.
#     """
#     return external_call["tcgetwinsize", c_int, c_int, UnsafePointer[winsize]](fd, winsize_p)


# fn tcsetwinsize(fd: c_int, winsize_p: UnsafePointer[winsize]) -> c_int:
#     """Libc POSIX `tcgetwinsize` function
#     Reference: https://man.netbsd.org/tcsetwinsize.3
#     Fn signature: int tcsetwinsize(int fd, const struct winsize *sws).

#     Args:
#         fd: File descriptor.
#         winsize_p: Pointer to a winsize struct.
#     """
#     return external_call["tcsetwinsize", c_int, c_int, UnsafePointer[winsize]](fd, winsize_p)


fn ttyname(fd: c_int) -> MutExternalPointer[c_char]:
    """Libc POSIX `ttyname` function.

    Get the name of the terminal associated with the file descriptor `fd`.

    Args:
        fd: File descriptor.

    Returns:
        A pointer to a string containing the name of the terminal.

    #### C Function:
    ```c
    char *ttyname(int fd);
    ```

    #### Notes:
    Reference: https://man7.org/linux/man-pages/man3/ttyname.3p.html.
    """
    return external_call["ttyname", MutExternalPointer[c_char], c_int](fd)


fn read(fd: c_int, buf: MutUnsafePointer[NoneType], size: c_size_t) -> c_int:
    """Libc POSIX `read` function.

    Read `size` bytes from file descriptor `fd` into the buffer `buf`.

    Args:
        fd: A File Descriptor.
        buf: A pointer to a buffer to store the read data.
        size: The number of bytes to read.

    Returns:
        The number of bytes read or -1 in case of failure.

    #### C Function:
    ```c
    ssize_t read(int fildes, void *buf, size_t nbyte);
    ```

    #### Notes:
    Reference: https://man7.org/linux/man-pages/man3/read.3p.html.
    """
    return external_call["read", c_int, type_of(fd), type_of(buf), type_of(size)](fd, buf, size)


comptime FileDescriptorBitSet = BitSet[1024]
"""A BitSet type for file descriptors."""


@fieldwise_init
@register_passable("trivial")
struct _TimeValue(Copyable, Movable):
    var seconds: time_t
    var microseconds: suseconds_t


fn _select(
    nfds: c_int,
    readfds: Pointer[mut=True, FileDescriptorBitSet],
    writefds: Pointer[mut=True, BitSet[1]],
    exceptfds: Pointer[mut=True, BitSet[1]],
    timeout: Pointer[mut=True, _TimeValue],
) -> c_int:
    """Libc POSIX `select` function.

    Args:
        nfds: The highest-numbered file descriptor in any of the three sets, plus 1.
        readfds: A pointer to the set of file descriptors to read from.
        writefds: A pointer to the set of file descriptors to write to.
        exceptfds: A pointer to the set of file descriptors to check for exceptions.
        timeout: A pointer to a TimeValue struct to set a timeout.

    Returns:
        The number of file descriptors in the sets or -1 in case of failure.

    #### C Function:
    ```c
    int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
    ```

    #### Notes:
    Reference: https://man7.org/linux/man-pages/man2/select.2.html
    """
    return external_call[
        "select",
        c_int,  # FnName, RetType
    ](nfds, readfds, writefds, exceptfds, timeout)


fn select(
    highest_fd: c_int,
    mut read_fds: FileDescriptorBitSet,
    mut write_fds: BitSet[1],
    mut except_fds: BitSet[1],
    mut timeout: _TimeValue,
) raises -> None:
    """Libc POSIX `select` function.

    Args:
        highest_fd: The highest-numbered file descriptor in any of the three sets, plus 1.
        read_fds: A pointer to the set of file descriptors to read from.
        write_fds: A pointer to the set of file descriptors to write to.
        except_fds: A pointer to the set of file descriptors to check for exceptions.
        timeout: A pointer to a TimeValue struct to set a timeout.

    Raises:
        Error: [EABADF] An invalid file descriptor was given in one of the sets.
        Error: [EINTR] A signal was caught.
        Error: [EINVAL] nfds is negative or exceeds the RLIMIT_NOFILE resource limit
        Error: [ENOMEM] Unable to allocate memory for internal tables.
        Error: [UNKNOWN] Unknown error occurred when calling C's `select` function.
        Error: Select has timed out while waiting for file descriptors to become ready.

    #### C Function Signature:
    ```c
    int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
    ```

    #### Reference
    https://man7.org/linux/man-pages/man2/select.2.html.
    """
    var result = _select(
        highest_fd,
        Pointer(to=read_fds),
        Pointer(to=write_fds),
        Pointer(to=except_fds),
        Pointer(to=timeout),
    )

    if result == -1:
        var errno = c.get_errno()
        if errno == errno.EBADF:
            raise Error("[EBADF] An invalid file descriptor was given in one of the sets.")
        elif errno == errno.EINTR:
            raise Error("[EINTR] A signal was caught.")
        elif errno == errno.EINVAL:
            raise Error("[EINVAL] nfds is negative or exceeds the RLIMIT_NOFILE resource limit.")
        elif errno == errno.ENOMEM:
            raise Error("[ENOMEM] Unable to allocate memory for internal tables.")
        else:
            raise Error("[UNKNOWN] Unknown error occurred.")
    elif result == 0:
        raise Error("Select has timed out while waiting for file descriptors to become ready.")
